<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xenium: xenium::harris_michael_hash_map&lt; Key, Value, Policies &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xenium
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>xenium</b></li><li class="navelem"><a class="el" href="classxenium_1_1harris__michael__hash__map.html">harris_michael_hash_map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classxenium_1_1harris__michael__hash__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xenium::harris_michael_hash_map&lt; Key, Value, Policies &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A generic lock-free hash-map.  
 <a href="classxenium_1_1harris__michael__hash__map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="harris__michael__hash__map_8hpp_source.html">harris_michael_hash_map.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxenium_1_1harris__michael__hash__map_1_1accessor.html">accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An accessor to safely access the value of an element.  <a href="classxenium_1_1harris__michael__hash__map_1_1accessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxenium_1_1harris__michael__hash__map_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ForwardIterator to safely iterate the hash-map.  <a href="classxenium_1_1harris__michael__hash__map_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6e96feeb90a8ad2e2f16363e36baa7b2"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a6e96feeb90a8ad2e2f16363e36baa7b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxenium_1_1harris__michael__hash__map.html#a6e96feeb90a8ad2e2f16363e36baa7b2">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6e96feeb90a8ad2e2f16363e36baa7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container if the container doesn't already contain an element with an equivalent key. The element is constructed in-place with the given <code>args</code>.  <a href="classxenium_1_1harris__michael__hash__map.html#a6e96feeb90a8ad2e2f16363e36baa7b2">More...</a><br /></td></tr>
<tr class="separator:a6e96feeb90a8ad2e2f16363e36baa7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283436ac7d83aa8a5d4893b7e9bb9db9"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a283436ac7d83aa8a5d4893b7e9bb9db9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classxenium_1_1harris__michael__hash__map_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxenium_1_1harris__michael__hash__map.html#a283436ac7d83aa8a5d4893b7e9bb9db9">emplace_or_get</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a283436ac7d83aa8a5d4893b7e9bb9db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container if the container doesn't already contain an element with an equivalent key. The element is constructed in-place with the given <code>args</code>.  <a href="classxenium_1_1harris__michael__hash__map.html#a283436ac7d83aa8a5d4893b7e9bb9db9">More...</a><br /></td></tr>
<tr class="separator:a283436ac7d83aa8a5d4893b7e9bb9db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3773c51771d44ed01b3c1ad3a5df17da"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a3773c51771d44ed01b3c1ad3a5df17da"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classxenium_1_1harris__michael__hash__map_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxenium_1_1harris__michael__hash__map.html#a3773c51771d44ed01b3c1ad3a5df17da">get_or_emplace</a> (Key key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3773c51771d44ed01b3c1ad3a5df17da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container if the container doesn't already contain an element with an equivalent key. The element is constructed as <code>value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&lt;Args&gt;(args)...))</code>.  <a href="classxenium_1_1harris__michael__hash__map.html#a3773c51771d44ed01b3c1ad3a5df17da">More...</a><br /></td></tr>
<tr class="separator:a3773c51771d44ed01b3c1ad3a5df17da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dfece66a4aaef01665899dc6ab16ea"><td class="memTemplParams" colspan="2">template&lt;class Factory &gt; </td></tr>
<tr class="memitem:ac4dfece66a4aaef01665899dc6ab16ea"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classxenium_1_1harris__michael__hash__map_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxenium_1_1harris__michael__hash__map.html#ac4dfece66a4aaef01665899dc6ab16ea">get_or_emplace_lazy</a> (Key key, Factory factory)</td></tr>
<tr class="memdesc:ac4dfece66a4aaef01665899dc6ab16ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container if the container doesn't already contain an element with an equivalent key. The value for the newly constructed element is created by calling <code>value_factory</code>.  <a href="classxenium_1_1harris__michael__hash__map.html#ac4dfece66a4aaef01665899dc6ab16ea">More...</a><br /></td></tr>
<tr class="separator:ac4dfece66a4aaef01665899dc6ab16ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f167fb90e173c1994b093482cf6357"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxenium_1_1harris__michael__hash__map.html#a57f167fb90e173c1994b093482cf6357">erase</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a57f167fb90e173c1994b093482cf6357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element with the key equivalent to key (if one exists).  <a href="classxenium_1_1harris__michael__hash__map.html#a57f167fb90e173c1994b093482cf6357">More...</a><br /></td></tr>
<tr class="separator:a57f167fb90e173c1994b093482cf6357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1333f5fb73d8bbffc298465990f46078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxenium_1_1harris__michael__hash__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxenium_1_1harris__michael__hash__map.html#a1333f5fb73d8bbffc298465990f46078">erase</a> (<a class="el" href="classxenium_1_1harris__michael__hash__map_1_1iterator.html">iterator</a> pos)</td></tr>
<tr class="memdesc:a1333f5fb73d8bbffc298465990f46078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified element from the container.  <a href="classxenium_1_1harris__michael__hash__map.html#a1333f5fb73d8bbffc298465990f46078">More...</a><br /></td></tr>
<tr class="separator:a1333f5fb73d8bbffc298465990f46078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb586ba8e0239488a1d017d40a75965b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxenium_1_1harris__michael__hash__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxenium_1_1harris__michael__hash__map.html#acb586ba8e0239488a1d017d40a75965b">find</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:acb586ba8e0239488a1d017d40a75965b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classxenium_1_1harris__michael__hash__map.html#acb586ba8e0239488a1d017d40a75965b">More...</a><br /></td></tr>
<tr class="separator:acb586ba8e0239488a1d017d40a75965b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6931a56571e4397f4ce368bfaa32c364"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxenium_1_1harris__michael__hash__map.html#a6931a56571e4397f4ce368bfaa32c364">contains</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a6931a56571e4397f4ce368bfaa32c364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key equivalent to key in the container.  <a href="classxenium_1_1harris__michael__hash__map.html#a6931a56571e4397f4ce368bfaa32c364">More...</a><br /></td></tr>
<tr class="separator:a6931a56571e4397f4ce368bfaa32c364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d15860e9dda46158747c97cd9f26af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxenium_1_1harris__michael__hash__map_1_1accessor.html">accessor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxenium_1_1harris__michael__hash__map.html#a75d15860e9dda46158747c97cd9f26af">operator[]</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a75d15860e9dda46158747c97cd9f26af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>accessor</code>  <a href="classxenium_1_1harris__michael__hash__map.html#a75d15860e9dda46158747c97cd9f26af">More...</a><br /></td></tr>
<tr class="separator:a75d15860e9dda46158747c97cd9f26af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74f9a97ced02246e0e6f06e80347949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxenium_1_1harris__michael__hash__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxenium_1_1harris__michael__hash__map.html#ae74f9a97ced02246e0e6f06e80347949">begin</a> ()</td></tr>
<tr class="memdesc:ae74f9a97ced02246e0e6f06e80347949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classxenium_1_1harris__michael__hash__map.html#ae74f9a97ced02246e0e6f06e80347949">More...</a><br /></td></tr>
<tr class="separator:ae74f9a97ced02246e0e6f06e80347949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec5614173bfbb86456f167d684accb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxenium_1_1harris__michael__hash__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxenium_1_1harris__michael__hash__map.html#a4ec5614173bfbb86456f167d684accb6">end</a> ()</td></tr>
<tr class="memdesc:a4ec5614173bfbb86456f167d684accb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classxenium_1_1harris__michael__hash__map.html#a4ec5614173bfbb86456f167d684accb6">More...</a><br /></td></tr>
<tr class="separator:a4ec5614173bfbb86456f167d684accb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class Value, class... Policies&gt;<br />
class xenium::harris_michael_hash_map&lt; Key, Value, Policies &gt;</h3>

<p>A generic lock-free hash-map. </p>
<p>This hash-map consists of a fixed number of buckets were each bucket is essentially a <code><a class="el" href="classxenium_1_1harris__michael__list__based__set.html" title="A lock-free container that contains a sorted set of unique objects of type Key.">harris_michael_list_based_set</a></code> instance. The number of buckets is fixed, so the hash-map does not support dynamic resizing.</p>
<p>This hash-map is less efficient than many other available concurrent hash-maps, but it is lock-free and fully generic, i.e., it supports arbitrary types for <code>Key</code> and <code>Value</code>.</p>
<p>This data structure is based on the solution proposed by Michael [<a href="index.html#ref-michael-2002">Mic02</a>] which builds upon the original proposal by Harris [<a href="index.html#ref-harris-2001">Har01</a>].</p>
<p>Supported policies:</p><ul>
<li><code><a class="el" href="structxenium_1_1policy_1_1reclaimer.html" title="Policy to configure the reclamation scheme to be used.">xenium::policy::reclaimer</a></code><br  />
 Defines the reclamation scheme to be used for internal nodes. (<b>required</b>)</li>
<li><code><a class="el" href="structxenium_1_1policy_1_1hash.html" title="Policy to configure the hash function.">xenium::policy::hash</a></code><br  />
 Defines the hash function. (<em>optional</em>; defaults to <code><a class="el" href="structxenium_1_1hash.html" title="Slim wrapper around std::hash with specialization for pointer types.">xenium::hash</a>&lt;Key&gt;</code>)</li>
<li><code><a class="el" href="structxenium_1_1policy_1_1map__to__bucket.html" title="Policy to configure the function that maps the hash value to a bucket in harris_michael_hash_map.">xenium::policy::map_to_bucket</a></code><br  />
 Defines the function that is used to map the calculated hash to a bucket. (<em>optional</em>; defaults to <code>xenium::utils::modulo&lt;std::size_t&gt;</code>)</li>
<li><code><a class="el" href="structxenium_1_1policy_1_1backoff.html" title="Policy to configure the backoff strategy.">xenium::policy::backoff</a></code><br  />
 Defines the backoff strategy. (<em>optional</em>; defaults to <code><a class="el" href="structxenium_1_1no__backoff.html" title="Dummy backoff strategy that does nothing.">xenium::no_backoff</a></code>)</li>
<li><code><a class="el" href="structxenium_1_1policy_1_1buckets.html" title="Policy to configure the number of buckets in harris_michael_hash_map.">xenium::policy::buckets</a></code><br  />
 Defines the number of buckets. (<em>optional</em>; defaults to 512)</li>
<li><code><a class="el" href="structxenium_1_1policy_1_1memoize__hash.html" title="Policy to configure whether the hash value should be stored and used during lookup operations in harr...">xenium::policy::memoize_hash</a></code><br  />
 Defines whether the hash should be stored and used during lookup operations. (<em>optional</em>; defaults to false for scalar <code>Key</code> types; otherwise true)</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td></td></tr>
    <tr><td class="paramname">Value</td><td></td></tr>
    <tr><td class="paramname">Policies</td><td>list of policies to customize the behaviour </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae74f9a97ced02246e0e6f06e80347949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74f9a97ced02246e0e6f06e80347949">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Value , class... Policies&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxenium_1_1harris__michael__hash__map.html">xenium::harris_michael_hash_map</a>&lt; Key, Value, Policies &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element </dd></dl>

</div>
</div>
<a id="a6931a56571e4397f4ce368bfaa32c364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6931a56571e4397f4ce368bfaa32c364">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Value , class... Policies&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxenium_1_1harris__michael__hash__map.html">xenium::harris_michael_hash_map</a>&lt; Key, Value, Policies &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if there is an element with key equivalent to key in the container. </p>
<p>Progress guarantees: lock-free</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the element to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there is such an element, otherwise <code>false</code> </dd></dl>

</div>
</div>
<a id="a6e96feeb90a8ad2e2f16363e36baa7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e96feeb90a8ad2e2f16363e36baa7b2">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Value , class... Policies&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxenium_1_1harris__michael__hash__map.html">xenium::harris_michael_hash_map</a>&lt; Key, Value, Policies &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new element into the container if the container doesn't already contain an element with an equivalent key. The element is constructed in-place with the given <code>args</code>. </p>
<p>The element is always constructed. If there already is an element with the key in the container, the newly constructed element will be destroyed immediately.</p>
<p>No iterators or references are invalidated.</p>
<p>Progress guarantees: lock-free</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an element was inserted, otherwise <code>false</code> </dd></dl>

</div>
</div>
<a id="a283436ac7d83aa8a5d4893b7e9bb9db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283436ac7d83aa8a5d4893b7e9bb9db9">&#9670;&nbsp;</a></span>emplace_or_get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Value , class... Policies&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classxenium_1_1harris__michael__hash__map_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="classxenium_1_1harris__michael__hash__map.html">xenium::harris_michael_hash_map</a>&lt; Key, Value, Policies &gt;::emplace_or_get </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new element into the container if the container doesn't already contain an element with an equivalent key. The element is constructed in-place with the given <code>args</code>. </p>
<p>The element is always constructed. If there already is an element with the key in the container, the newly constructed element will be destroyed immediately.</p>
<p>No iterators or references are invalidated.</p>
<p>Progress guarantees: lock-free</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place; <code>true</code> if an element was inserted, otherwise <code>false</code> </dd></dl>

</div>
</div>
<a id="a4ec5614173bfbb86456f167d684accb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec5614173bfbb86456f167d684accb6">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Value , class... Policies&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxenium_1_1harris__michael__hash__map.html">xenium::harris_michael_hash_map</a>&lt; Key, Value, Policies &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior. </p><dl class="section return"><dt>Returns</dt><dd>iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a57f167fb90e173c1994b093482cf6357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f167fb90e173c1994b093482cf6357">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Value , class... Policies&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxenium_1_1harris__michael__hash__map.html">xenium::harris_michael_hash_map</a>&lt; Key, Value, Policies &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the element with the key equivalent to key (if one exists). </p>
<p>No iterators or references are invalidated.</p>
<p>Progress guarantees: lock-free</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an element was removed, otherwise <code>false</code> </dd></dl>

</div>
</div>
<a id="a1333f5fb73d8bbffc298465990f46078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1333f5fb73d8bbffc298465990f46078">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Value , class... Policies&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxenium_1_1harris__michael__hash__map.html">xenium::harris_michael_hash_map</a>&lt; Key, Value, Policies &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxenium_1_1harris__michael__hash__map_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified element from the container. </p>
<p>No iterators or references are invalidated.</p>
<p>Progress guarantees: lock-free</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the iterator identifying the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the last removed element </dd></dl>

</div>
</div>
<a id="acb586ba8e0239488a1d017d40a75965b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb586ba8e0239488a1d017d40a75965b">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Value , class... Policies&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxenium_1_1harris__michael__hash__map.html">xenium::harris_michael_hash_map</a>&lt; Key, Value, Policies &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<p>Progress guarantees: lock-free</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the element to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to an element with key equivalent to key if such element is found, otherwise past-the-end iterator </dd></dl>

</div>
</div>
<a id="a3773c51771d44ed01b3c1ad3a5df17da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3773c51771d44ed01b3c1ad3a5df17da">&#9670;&nbsp;</a></span>get_or_emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Value , class... Policies&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classxenium_1_1harris__michael__hash__map_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="classxenium_1_1harris__michael__hash__map.html">xenium::harris_michael_hash_map</a>&lt; Key, Value, Policies &gt;::get_or_emplace </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new element into the container if the container doesn't already contain an element with an equivalent key. The element is constructed as <code>value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&lt;Args&gt;(args)...))</code>. </p>
<p>The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</p>
<p>No iterators or references are invalidated. Progress guarantees: lock-free</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of element to be inserted. </td></tr>
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place; <code>true</code> if an element was inserted, otherwise <code>false</code> </dd></dl>

</div>
</div>
<a id="ac4dfece66a4aaef01665899dc6ab16ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dfece66a4aaef01665899dc6ab16ea">&#9670;&nbsp;</a></span>get_or_emplace_lazy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Value , class... Policies&gt; </div>
<div class="memtemplate">
template&lt;class Factory &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classxenium_1_1harris__michael__hash__map_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="classxenium_1_1harris__michael__hash__map.html">xenium::harris_michael_hash_map</a>&lt; Key, Value, Policies &gt;::get_or_emplace_lazy </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Factory&#160;</td>
          <td class="paramname"><em>factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new element into the container if the container doesn't already contain an element with an equivalent key. The value for the newly constructed element is created by calling <code>value_factory</code>. </p>
<p>The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</p>
<p>No iterators or references are invalidated. Progress guarantees: lock-free</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of element to be inserted. </td></tr>
    <tr><td class="paramname">factory</td><td>a functor that is used to create the <code>Value</code> instance when constructing the new element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place; <code>true</code> if an element was inserted, otherwise <code>false</code> </dd></dl>

</div>
</div>
<a id="a75d15860e9dda46158747c97cd9f26af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d15860e9dda46158747c97cd9f26af">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Value , class... Policies&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxenium_1_1harris__michael__hash__map.html">xenium::harris_michael_hash_map</a>&lt; Key, Value, Policies &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>accessor</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an accessor to the element's value </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
