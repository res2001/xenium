<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xenium: Reclamation scheme interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xenium
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Reclamation scheme interface </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#enable_concurrent_ptr">enable_concurrent_ptr</a></li>
<li class="level1"><a href="#deletable_object">deletable_object</a></li>
<li class="level1"><a href="#marked_ptr">marked_ptr</a></li>
<li class="level1"><a href="#concurrent_ptr">concurrent_ptr</a></li>
<li class="level1"><a href="#guard_ptr">guard_ptr</a></li>
<li class="level1"><a href="#region_guard">region_guard</a></li>
</ul>
</div>
<div class="textblock"><p>General information about the interface used to implement all the reclamation schemes.</p>
<p>The implementation of the reclamation schemes is based on an adapted version of the interface proposed by Robison [<a href="index.html#ref-robison-2013">Rob13</a>], which defines the following fundamental abstractions:</p><ul>
<li>A <code>marked_ptr</code> allows one or more low-order bits to be borrowed (many lock-free algorithms rely on such mark tricks).</li>
<li>A <code>concurrent_ptr</code> acts like an atomic <code>marked_ptr</code>, i.e., it supports atomic operations.</li>
<li>A <code>guard_ptr</code> is an object that can atomically take a snapshot of the value of a <code>concurrent_ptr</code> and if the target has not yet been deleted, guarantees that the target will not be deleted as long as the <code>guard_ptr</code> holds a pointer to it.</li>
</ul>
<p>It is important to note that only <code>guard_ptr</code> references protect against deletion. In effect, a <code>concurrent_ptr</code> is a "weak" pointer and a <code>guard_ptr</code> is a "shared ownership" pointer, conceptually similar to <code>std::weak_ptr</code> and <code>std::shared_ptr</code> with the following key differences:</p><ul>
<li><code>concurrent_ptr</code> and <code>guard_ptr</code> are abstract interfaces (a.k.a. "concepts"), not concrete interfaces.</li>
<li>They support a snapshot operation that is conceptually similar to the <code>std::weak_ptr::lock()</code> method.</li>
<li>A <code>std::weak_ptr</code> can indicate whether it has "expired", i.e., its target was deleted. A <code>concurrent_ptr</code> gives no such indication even if, as it can in some cases, points to freed memory.</li>
</ul>
<p>A reclaimer type <code>R</code> has to define the following abstractions:</p><ul>
<li><code>R::concurrent_ptr&lt;T&gt;</code>: acts like an atomic markable pointer to objects of type <code>T</code> and provides an interface that is compatible with that of <code>std::atomic</code>. The class <code>T</code> must be derived from <code>enable_concurrent_ptr</code>.</li>
<li><code>R::enable_concurrent_ptr&lt;T, N, D&gt;</code>: defines a mandatory base class for targets of <code>concurrent_ptr</code>; <code>T</code> is the derived class, <code>N</code> is the number of mark bits supported, which defaults to zero, and <code>D</code> is the deleter type that should be used for all objects of type <code>T</code>.</li>
<li><code>R::region_guard</code>: allows some reclamation schemes to amortize the overhead; this is explained in more detail in <a class="el" href="reclamation_schemes.html#region_guard">region_guard</a>.</li>
</ul>
<p>The intent of <code>enable_concurrent_ptr&lt;T, N, D&gt;</code> is to provide implementers of reclaimers with two things:</p><ul>
<li>A way to force the alignment of targets, which is a common way to provide mark bits in the pointers.</li>
<li>A place to embed reclaimer state, such as reference counts, in the user's objects.</li>
</ul>
<p>The class <code>concurrent_ptr&lt;T&gt;</code> provides two auxiliary types:</p><ul>
<li><code>concurrent_ptr&lt;T&gt;::marked_ptr</code> : Acts like a pointer, but has <code>N</code> mark bits, where <code>N</code> is specified by the base class <code>enable_concurrent_ptr&lt;T, N&gt;</code> of <code>T</code>.</li>
<li><code>concurrent_ptr&lt;T&gt;::guard_ptr</code> : Similar to a <code>marked_ptr</code>, but has shared ownership of its target <em>if</em> the target has not been deleted.</li>
</ul>
<p>To obtain a snapshot from <code>concurrent_ptr</code> and populate a <code>guard_ptr</code> the <code>acquire</code> and <code>acquire_if_equal</code> methods can be used. In wait-free algorithms, <code>acquire</code> may be problematic with some schemes like <code>hazard_pointer</code> or <code>lock_free_ref_count</code>, because it may have to loop indefinitely. For these cases <code>acquire_if_equal</code> can be used, as it simply stops trying if the value in variable <code>p</code> does not match the provided value in variable <code>m</code> and reports whether it was successful or not.</p>
<p>Releasing a <code>guard_ptr</code> follows the standard smart pointer interface. For a <code>guard_ptr</code> instance <code>g</code>, the operation <code>g.reset</code> releases ownership and sets <code>g</code> to <code>nullptr</code>; the destructor of <code>guard_ptr</code> implicitly calls <code>reset</code>.</p>
<p>In order to release a node, the <code>reclaim</code> method on a <code>guard_ptr</code> has to be called. This operation also resets the <code>guard_ptr</code>.</p>
<p>Here is an example of these types and how they are used: </p><div class="fragment"><div class="line"><span class="comment">// Let&#39;s assume we have a type &quot;Reclaimer&quot; that implements this interface.</span></div>
<div class="line"><span class="comment">// Forward declaration of our node struct so we can use it in the following aliases.</span></div>
<div class="line"><span class="keyword">struct </span>node;</div>
<div class="line"><span class="comment">// Define a number of aliases for simpler code.</span></div>
<div class="line"><span class="keyword">using</span> concurrent_ptr = <span class="keyword">typename</span> Reclaimer::template concurrent_ptr&lt;node, 0&gt;;</div>
<div class="line"><span class="keyword">using</span> marked_ptr = <span class="keyword">typename</span> concurrent_ptr::marked_ptr;</div>
<div class="line"><span class="keyword">using</span> guard_ptr = <span class="keyword">typename</span> concurrent_ptr::guard_ptr;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We want to use our node with concurrent_ptr, so we have to derive</span></div>
<div class="line"><span class="comment">// it from enable_concurrent_ptr.</span></div>
<div class="line"><span class="keyword">struct </span>node : Reclaimer::template enable_concurrent_ptr&lt;node&gt; {};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Let&#39;s create a new node and store it in some publicly available concurrent_ptr.</span></div>
<div class="line">marked_ptr new_node = <span class="keyword">new</span> node();</div>
<div class="line">concurrent_ptr cp;</div>
<div class="line">cp.store(new_node);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Acquire a guard to the node referenced by cp.</span></div>
<div class="line"><span class="comment">// This will protect the node from getting reclaimed as long as the guard_ptr exists.</span></div>
<div class="line">guard_ptr guard;</div>
<div class="line">guard.acquire(cp);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Mark the node for reclamation. This will reset the guard_ptr and ensure that the</span></div>
<div class="line"><span class="comment">// node gets reclaimed once it is safe.</span></div>
<div class="line">guard.reclaim();</div>
</div><!-- fragment --><h1><a class="anchor" id="enable_concurrent_ptr"></a>
enable_concurrent_ptr</h1>
<p>Every reclaimer must define a class <code>enable_concurrent_pointer</code> that is used as mandatory base class for targets of <code>concurrent_ptr</code>. This base class does not only define the <code>number_of_mark_bits</code> and an alias for the <code>Deleter</code> for internal use in the reclaimer, but also allows to enforce alignment of instances or to store additional information like a reference counter. The minimal definition of such a class looks like this: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">class </span>T,</div>
<div class="line">  std::size_t N = 0,</div>
<div class="line">  <span class="keyword">class </span>DeleterT = std::default_delete&lt;T&gt;&gt;</div>
<div class="line"><span class="keyword">struct </span>enable_concurrent_ptr</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> constexpr std::size_t number_of_mark_bits = N;</div>
<div class="line">  <span class="keyword">using</span> Deleter = DeleterT;</div>
<div class="line">};</div>
</div><!-- fragment --><p><code>enable_concurrent_pointer</code> is a class template with the following template parameters:</p><ul>
<li><code>T</code> - is the derived class (this is an application of the <a href="https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/"><em>curiously recurring template pattern</em></a>).</li>
<li><code>N</code> - is the number of mark bits that a <code>marked_ptr</code> must reserve when used with this class; this parameter defaults to zero.</li>
<li><code>DeleterT</code> - is the deleter functor that shall be applied once an object can safely be reclaimed.</li>
</ul>
<p>The class must define a member <code>number_of_mark_bits</code> that is set to <code>N</code> and a type alias <code>Deleter</code>. In the original proposal the <code>Deleter</code> was not a parameter of <code>enable_concurrent_ptr</code> but of <code>concurrent_ptr</code>. However, all implemented reclamation schemes except LFRC collect the <em>to-be-reclaimed</em> nodes in some list in order to defer reclamation until a later time when it is safe to do so. Such a list can contain arbitrary nodes from different data structures, potentially using different deleters. The information which deleter shall be used must therefore be stored together with the node. But if this information is not already part of the node itself, it would require an additional memory allocation to store this information, even in cases where the deleter itself has no data members like <code>std::default_deleter</code>. In order to avoid this additional memory allocation, the <code>Deleter</code> parameter is part of the <code>enabled_concurrent_ptr</code> class, which allows to embed <code>Deleter</code> instances directly in the node. For this the internal helper class <a class="el" href="reclamation_schemes.html#deletable_object">deletable_object</a> comes into play.</p>
<h1><a class="anchor" id="deletable_object"></a>
deletable_object</h1>
<p><code>deletable_object</code> is an internal helper class that is used by most of the reclamation schemes as the common base class for <code>enable_concurrent_ptr</code>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>deletable_object</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> delete_self() = 0;</div>
<div class="line">  deletable_object* next = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keyword">virtual</span> ~deletable_object() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>next</code> pointer is used to build the single-linked list of <em>to-be-reclaimed</em> nodes. The pure virtual <code>delete_self</code> method is required because such lists contain only pointers to <code>deletable_object</code> instances, but the <code>Deleter</code> expects an instance of the derived type. Therefore, a derived class has to override <code>delete_self</code> and call the deleter with the appropriate parameter. To avoid duplication of this code for each reclamation scheme, there are two different base classes which again make use of the <em>curiously recurring template pattern</em> to down-cast to the correct derived type which is handed down as template parameter. The two different base classes are <code>deletable_object_with_empty_deleter</code> and <code>deletable_object_with_non_empty_deleter</code>. This distinction is necessary because the size of an empty class is not zero, but one. Unconditionally storing a deleter instance as member in the object would therefore produce an unnecessary memory overhead that can be avoided this way. Instead of using these classes directly, the alias <code>deletable_object_impl</code> is used to verify whether the given deleter is an empty class and resolves to the correct base class.</p>
<p><code>deletable_object_with_non_empty_deleter</code> contains an <code>aligned_storage</code> as buffer for a <code>Deleter</code> instance. When a deleter is set using the <code>set_deleter</code> method the deleter instance is <em>moved</em> into the buffer. This allows the <code>Deleter</code> type to be non-default-constructible.</p>
<p>The template parameter <code>Base</code> defaults to <code>deletable_object</code> which should be fine for most of the cases. In case there are special requirements this parameter can be used to define a custom base class as long as it defines the same interface as <code>deletable_object</code>. This is used for example in the implementations of <code>stamp_it</code> and <code>hazard_eras</code>, because these schemes requires that the base class can store additional information for retired nodes.</p>
<h1><a class="anchor" id="marked_ptr"></a>
marked_ptr</h1>
<p>Many lock-free algorithms rely on the ability to store special flags in a pointer. The <code>marked_ptr</code> class defines a high-level interface to a pointer of which a number of low-order bits can be borrowed to store additional information. The number of bits that shall be used can be defined via a template parameter. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, std::<span class="keywordtype">size_t</span> N&gt;</div>
<div class="line"><span class="keyword">class </span>marked_ptr {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Construct a marked ptr</span></div>
<div class="line">  marked_ptr(T* p = <span class="keyword">nullptr</span>, uintptr_t mark = 0) noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set to nullptr</span></div>
<div class="line">  <span class="keywordtype">void</span> reset() noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get mark bits</span></div>
<div class="line">  uintptr_t mark() const noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get underlying pointer (with mark bits stripped off).</span></div>
<div class="line">  T* get() const noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// True if get() != nullptr || mark() != 0</span></div>
<div class="line">  explicit operator <span class="keywordtype">bool</span>() const noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get pointer with mark bits stripped off.</span></div>
<div class="line">  T* operator-&gt;() const noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get reference to target of pointer.</span></div>
<div class="line">  T&amp; operator*() const noexcept;</div>
<div class="line"> </div>
<div class="line">  inline friend <span class="keywordtype">bool</span> operator==(const marked_ptr&amp; l, const marked_ptr&amp; r);</div>
<div class="line">  inline friend <span class="keywordtype">bool</span> operator!=(const marked_ptr&amp; l, const marked_ptr&amp; r);</div>
<div class="line"> </div>
<div class="line">  static constexpr std::<span class="keywordtype">size_t</span> number_of_mark_bits = N;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Runtime assertions ensure that the specified mark value does not use more bits than reserved, as well as that the pointer value does not occupy bits that are reserved for marking.</p>
<h1><a class="anchor" id="concurrent_ptr"></a>
concurrent_ptr</h1>
<p>A <code>concurrent_ptr</code> is basically an atomic <code>marked_ptr</code>; its interface is compatible to that of <code>std::atomic</code>. In addition it defines aliases for the reclaimer's <code>marked_ptr</code> and <code>guard_ptr</code> types. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">class </span>T,</div>
<div class="line">  std::size_t N,</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span>, std::<span class="keywordtype">size_t</span>&gt; <span class="keyword">class </span>MarkedPtr,</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2, <span class="keyword">class</span> MarkedPtrT, <span class="keyword">class</span> Deleter&gt; <span class="keyword">class </span>GuardPtr,</div>
<div class="line">  <span class="keyword">class </span>DefaultDelete = std::default_delete&lt;T&gt;</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">class </span>concurrent_ptr {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">struct </span>marked_ptr : MarkedPtr&lt;T, N&gt; {};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> D = DefaultDelete&gt;</div>
<div class="line">  <span class="keyword">using</span> guard_ptr = GuardPtr&lt;T, marked_ptr, D&gt;;</div>
<div class="line"> </div>
<div class="line">  concurrent_ptr(<span class="keyword">const</span> marked_ptr&amp; p = marked_ptr()) noexcept : ptr(p) {}</div>
<div class="line">  concurrent_ptr(<span class="keyword">const</span> concurrent_ptr&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  concurrent_ptr(concurrent_ptr&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  concurrent_ptr&amp; operator=(<span class="keyword">const</span> concurrent_ptr&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  concurrent_ptr&amp; operator=(concurrent_ptr&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Atomic load that does not guard target from being reclaimed.</span></div>
<div class="line">  marked_ptr load(std::memory_order order = std::memory_order_seq_cst) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Atomic store.</span></div>
<div class="line">  <span class="keywordtype">void</span> store(<span class="keyword">const</span> marked_ptr&amp; src,</div>
<div class="line">             std::memory_order order = std::memory_order_seq_cst);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Shorthand for store (src.get())</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> D&gt;</div>
<div class="line">  <span class="keywordtype">void</span> store(<span class="keyword">const</span> guard_ptr&lt;D&gt;&amp; src,</div>
<div class="line">             std::memory_order order = std::memory_order_seq_cst);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> compare_exchange_weak(marked_ptr&amp; expected, marked_ptr desired,</div>
<div class="line">    std::memory_order order = std::memory_order_seq_cst);</div>
<div class="line">  <span class="keywordtype">bool</span> compare_exchange_weak(marked_ptr&amp; expected, marked_ptr desired,</div>
<div class="line">    std::memory_order order = std::memory_order_seq_cst) <span class="keyword">volatile</span>;</div>
<div class="line">  <span class="keywordtype">bool</span> compare_exchange_weak(marked_ptr&amp; expected, marked_ptr desired,</div>
<div class="line">    std::memory_order success, std::memory_order failure);</div>
<div class="line">  <span class="keywordtype">bool</span> compare_exchange_weak(marked_ptr&amp; expected, marked_ptr desired,</div>
<div class="line">    std::memory_order success, std::memory_order failure) <span class="keyword">volatile</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> compare_exchange_strong(marked_ptr&amp; expected, marked_ptr desired,</div>
<div class="line">    std::memory_order order = std::memory_order_seq_cst);</div>
<div class="line">  <span class="keywordtype">bool</span> compare_exchange_strong(marked_ptr&amp; expected, marked_ptr desired,</div>
<div class="line">    std::memory_order order = std::memory_order_seq_cst) <span class="keyword">volatile</span>;</div>
<div class="line">  <span class="keywordtype">bool</span> compare_exchange_strong(marked_ptr&amp; expected, marked_ptr desired,</div>
<div class="line">    std::memory_order success, std::memory_order failure);</div>
<div class="line">  <span class="keywordtype">bool</span> compare_exchange_strong(marked_ptr&amp; expected, marked_ptr desired,</div>
<div class="line">    std::memory_order success, std::memory_order failure) <span class="keyword">volatile</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="guard_ptr"></a>
guard_ptr</h1>
<p>A <code>guard_ptr</code> is basically a <code>marked_ptr</code> that protects the object that it points to from being reclaimed. In that sense it is conceptually similar to a <code>std::shared_ptr</code>. In contrast to the other two pointer types, <code>guard_ptr</code> implementations are very specific to the concrete reclamation scheme. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>guard_ptr</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> Deleter = <span class="keyword">typename</span> T::Deleter;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  guard_ptr() noexcept;</div>
<div class="line">  ~guard_ptr();</div>
<div class="line">    </div>
<div class="line">  <span class="comment">// Guard a marked ptr.</span></div>
<div class="line">  explicit guard_ptr(const marked_ptr&amp; p);</div>
<div class="line">  </div>
<div class="line">  guard_ptr(const guard_ptr&amp; p);</div>
<div class="line">  guard_ptr(guard_ptr&amp;&amp; p) noexcept;</div>
<div class="line"> </div>
<div class="line">  guard_ptr&amp; operator=(const guard_ptr&amp; p) noexcept;</div>
<div class="line">  guard_ptr&amp; operator=(guard_ptr&amp;&amp; p) noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get underlying pointer</span></div>
<div class="line">  T* get() const noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get mark bits</span></div>
<div class="line">  uintptr_t mark() const noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Support implicit conversion from guard_ptr to marked_ptr.</span></div>
<div class="line">  operator marked_ptr() const noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// True if get() != nullptr || mark() != 0</span></div>
<div class="line">  explicit operator <span class="keywordtype">bool</span>() const noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get pointer with mark bits stripped off. Undefined if target has been reclaimed.</span></div>
<div class="line">  T* operator-&gt;() const noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get reference to target of pointer. Undefined if target has been reclaimed.</span></div>
<div class="line">  T&amp; operator*() const noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Swap two guards.</span></div>
<div class="line">  <span class="keywordtype">void</span> swap(guard_ptr&amp; g) noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Atomically take snapshot of p, and *if* it points to unreclaimed object,</span></div>
<div class="line">  <span class="comment">// acquire shared ownership of it.</span></div>
<div class="line">  <span class="keywordtype">void</span> acquire(concurrent_ptr&lt;T&gt;&amp; p,</div>
<div class="line">               std::memory_order order = std::memory_order_seq_cst);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Like acquire, but quit early if p != expected.</span></div>
<div class="line">  <span class="keywordtype">bool</span> acquire_if_equal(concurrent_ptr&lt;T&gt;&amp; p,</div>
<div class="line">                        const marked_ptr&amp; expected</div>
<div class="line">                        std::memory_order order = std::memory_order_seq_cst);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Release ownership. Postcondition: get() == nullptr.</span></div>
<div class="line">  <span class="keywordtype">void</span> reset() noexcept;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Reset. Deleter d will be applied some time after all owners release their ownership.</span></div>
<div class="line">  <span class="keywordtype">void</span> reclaim(Deleter d = Deleter()) noexcept;</div>
<div class="line">};</div>
</div><!-- fragment --><p>A <code>guard_ptr</code> has to be acquired by the methods <code>acquire</code> or <code>acquire_if_equal</code> to ensure that the <code>guard_ptr</code> holds a safe reference that protects the object from being reclaimed. These methods take a snapshot of the value of a <code>concurrent_ptr</code> and store a safe reference to the object in the <code>guard_ptr</code> if the target has not yet been deleted.</p>
<p>For some implemenations like <code>hazard_pointers</code>, <code>hazard_eras</code> or <code>lock_free_ref_count</code>, <code>acquire</code> may has to loop indefinitely in order to acquire a safe reference, which can be problematic in wait-free algorithms. In these cases <code>acquire_if_equal</code> can be used as it simply stops trying if the value in <code>p</code> does not match a provided value <code>m</code> and reports whether it was successful or not.</p>
<p>Both methods, <code>acquire</code> and <code>acquire_if_equal</code> take an optional <code>memory_order</code> parameter that defines the order of the read operation on the <code>concurrent_ptr</code> object <code>p</code>. The default value is <code>memory_order_seq_cst</code>.</p>
<p>Releasing a <code>guard_ptr</code> follows the standard smart pointer interface; the operation <code>g.reset</code> releases ownership and sets <code>g</code> to <code>nullptr</code>, the destructor of <code>guard_ptr</code> implicitly calls reset.</p>
<p>The <code>reclaim</code> method resets the <code>guard_ptr</code> and marks the node for deletion.</p>
<p>One important limitation of <code>guard_ptr</code>s is that they must not be moved between threads, i.e., move construction or move assignment operations must not be used to transfer ownership of a <code>guard_ptr</code> from one thread to another. The reason for this simply is that these move operations are optimized based on the assumption that both, the target and the source operands, belong to the same thread. However, copy construction and copy assignment do not suffer from this limitation.</p>
<h1><a class="anchor" id="region_guard"></a>
region_guard</h1>
<p>A <code>region_guard</code> is an additional concept that is not part of the proposal by Robison. However, some reclamation schemes like <code>epoch_based</code>, <code>new_epoch_based</code> or <code>stamp_it</code> use the concept of <em>critical regions</em>. In these schemes a <code>guard_ptr</code> can only exist inside a critical region, so unless the thread is already inside a critical region the <code>guard_ptr</code> automatically enters a new one. But entering and leaving critical regions are usually rather expensive operations, so <code>region_guard</code>s allow to amortize this overhead. The constructor of a <code>region_guard</code> enters a new region (unless the thread is already inside one) and, if it was the last one, leaves the region in the destructor. Any <code>guard_ptr</code> instances that are created inside the scope of the <code>region_guard</code> can simply use the current critical region and save the overhead of entering a new one.</p>
<p>The <code>region_guard</code> class does not define any member functions, it only uses the RAII concept to leave the region upon destruction.</p>
<p>In order to provide a consistent interface every reclamation scheme has to define a <code>region_guard</code> class regardless of whether the scheme actually supports this concept. For reclamation schemes that do not support it, it is sufficient to define an empty <code>region_guard</code> class. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
